commit 7cda952cd478d13da5970819e77b5af631df13c8
Author: benlong.zhou <benlong.zhou@amlogic.com>
Date:   Tue Apr 2 18:56:48 2013 +0800

     security key: key can be save in emmc
      1  key can be read/write from/to emmc ok
      2  modified initial process,it can be initial many times
      3  key area is hided, it is between "boot_env" and "logo"
      4  the offset and size of the key area must be same as uboot
      5  when the key was be operate, the operate same as nand key
      6  first cmd "echo emmc3 > version" is diffrent nand key

diff --git a/drivers/amlogic/cardreader/Kconfig b/drivers/amlogic/cardreader/Kconfig
index 2df8da4..2584625 100755
--- a/drivers/amlogic/cardreader/Kconfig
+++ b/drivers/amlogic/cardreader/Kconfig
@@ -49,8 +49,8 @@ config INAND_LP
 	bool "enable inand register last partition as a full block device"
 	depends on INAND
 	select SD_MMC
-config AML_CARD_KEY
-	bool "Meson key data store in card device (dev/nand_key) support"
+config AML_EMMC_KEY
+	bool "Meson key data store in emmc device support"
 	depends on INAND
 	depends on CARDREADER
 	depends on ARCH_MESON3 || ARCH_MESON6
diff --git a/drivers/amlogic/cardreader/Makefile b/drivers/amlogic/cardreader/Makefile
index 358f67e..2a12398 100755
--- a/drivers/amlogic/cardreader/Makefile
+++ b/drivers/amlogic/cardreader/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_CF) += cf/
 obj-$(CONFIG_MS_MSPRO) += ms/
 obj-$(CONFIG_XD) += xd/
 obj-$(CONFIG_AML_CARD_KEY)	+=	card_key.o
+obj-$(CONFIG_AML_EMMC_KEY) += emmc_key.o
 
 #include $(TOPDIR)/Rules.make
 
diff --git a/drivers/amlogic/cardreader/card_block.c b/drivers/amlogic/cardreader/card_block.c
index dda7431..a02cf8d 100755
--- a/drivers/amlogic/cardreader/card_block.c
+++ b/drivers/amlogic/cardreader/card_block.c
@@ -26,6 +26,7 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
+#include "card_data.h"
 
 static int major;
 #define CARD_SHIFT	4
@@ -44,6 +45,7 @@ static int card_blk_issue_rq(struct card_queue *cq, struct request *req);
 static int card_blk_probe(struct memory_card *card);
 static int card_blk_prep_rq(struct card_queue *cq, struct request *req);
 void card_queue_resume(struct card_queue *cq);
+#if 0
 struct card_blk_data {
 	spinlock_t lock;
 	struct gendisk *disk;
@@ -53,6 +55,8 @@ struct card_blk_data {
 	unsigned int block_bits;
 	unsigned int read_only;
 };
+#endif
+
 
 static DEFINE_MUTEX(open_lock);
 
@@ -613,7 +617,10 @@ static struct card_blk_data *card_blk_alloc(struct memory_card *card)
 	card_data->disk->queue = card_data->queue.queue;
 	card_data->disk->driverfs_dev = &card->dev;
 
+	//printk("%s:%d  444444444444444444,card->name:%s\n",__func__,__LINE__,card->name);
 	sprintf(card_data->disk->disk_name, "cardblk%s", card->name);
+	
+	//printk("%s:%d,major:%d,minors:%d,first_minor:%d,name:%s,\n",__func__,__LINE__,card_data->disk->major,card_data->disk->minors,card_data->disk->first_minor,card_data->disk->disk_name);
 
 	blk_queue_logical_block_size(card_data->queue.queue, 1 << card_data->block_bits);
 
@@ -673,6 +680,7 @@ static int card_blk_issue_rq(struct card_queue *cq, struct request *req)
 
 		card->host->card_type = card->card_type;
 		
+		//printk("%s:%d  444444444444444444\n",__func__,__LINE__);
 		card_queue_bounce_pre(cq);
 
 		card_wait_for_req(card->host, &brq);
@@ -1050,6 +1058,13 @@ static int card_blk_probe(struct memory_card *card)
 	add_disk(card_data->disk);
 	add_card_partition(card, card_data->disk, pinfo->partitions,
 			pinfo->nr_partitions);
+#ifdef CONFIG_AML_EMMC_KEY
+	if(card->card_type == CARD_INAND)
+	{
+		int emmc_key_init( void *keypara);
+		emmc_key_init(card);
+	}
+#endif
 
 	return 0;
 }
diff --git a/drivers/amlogic/cardreader/card_data.h b/drivers/amlogic/cardreader/card_data.h
new file mode 100644
index 0000000..4cc60dc
--- /dev/null
+++ b/drivers/amlogic/cardreader/card_data.h
@@ -0,0 +1,18 @@
+#ifndef __CARD__DATA__H_
+#define __CARD__DATA__H_
+
+#include <linux/cardreader/card_block.h>
+
+struct card_blk_data {
+	spinlock_t lock;
+	struct gendisk *disk;
+	struct card_queue queue;
+
+	unsigned int usage;
+	unsigned int block_bits;
+	unsigned int read_only;
+};
+
+
+#endif
+
diff --git a/drivers/amlogic/cardreader/card_key.c b/drivers/amlogic/cardreader/card_key.c
index d82400c..d3117d7 100755
--- a/drivers/amlogic/cardreader/card_key.c
+++ b/drivers/amlogic/cardreader/card_key.c
@@ -7,6 +7,7 @@
 #include <mach/irqs.h>
 #include <mach/card_io.h>
 //#include <mach/mod_gate.h>
+#if 0
 #include <linux/cardreader/card_block.h>
 #include <linux/cardreader/cardreader.h>
 #include <linux/cardreader/sdio.h>
@@ -17,7 +18,7 @@
 
 
 #include "sd/sd_protocol.h"
-
+#endif
 
 
 
diff --git a/drivers/amlogic/cardreader/emmc_key.c b/drivers/amlogic/cardreader/emmc_key.c
new file mode 100644
index 0000000..c978806
--- /dev/null
+++ b/drivers/amlogic/cardreader/emmc_key.c
@@ -0,0 +1,599 @@
+
+#include <linux/types.h>
+#include "emmc_key.h"
+//#include <linux/device.h>
+//#include <linux/blkdev.h>
+#if defined(EMMC_KEY_KERNEL)
+#include <linux/cardreader/card_block.h>
+#include <linux/err.h>
+#include "card_data.h"
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include "sd/sd_protocol.h"
+#include <linux/efuse.h>
+#endif
+/*
+ * kernel head file
+ * 
+ ********************************** */
+
+#ifdef EMMC_KEY_UBOOT
+#include <ubi_uboot.h>
+#include <mmc.h>
+#include <amlogic/securitykey.h>
+#endif
+/*
+ * uboot head file
+ * ****************************/
+
+static u32 emmckey_calculate_checksum(u8 *buf,u32 lenth)
+{
+	u32 checksum = 0;
+	u32 cnt;
+	for(cnt=0;cnt<lenth;cnt++){
+		checksum += buf[cnt];
+	}
+	return checksum;
+}
+static u32 uint_to_shift(u32 value)
+{
+	u32 shift=0;
+	while(value){
+		if(value > 1){
+			shift++;
+		}
+		value >>= 1;
+	}
+	return shift;
+}
+static int emmc_key_transfer(u8 *buf,u32 *value,u32 len,u32 direct)
+{
+	u8 checksum=0;
+	u32 i;
+	if(direct){
+		for(i=0;i<len;i++){
+			checksum += buf[i];
+		}
+		for(i=0;i<len;i++){
+			buf[i] ^= checksum;
+		}
+		*value = checksum;
+		return 0;
+	}
+	else{
+		checksum = *value;
+		for(i=0;i<len;i++){
+			buf[i] ^= checksum;
+		}
+		checksum = 0;
+		for(i=0;i<len;i++){
+			checksum += buf[i];
+		}
+		if(checksum == *value){
+			return 0;
+		}
+		return -1;
+	}
+}
+
+#if defined(EMMC_KEY_KERNEL)
+//static struct card_queue *memory_card_to_card_queue(struct memory_card *emmccard)
+//{
+//	return container_of(emmccard, struct card_queue, card);
+//}
+
+static int card_claim_card_get(struct memory_card *card)
+{
+	if(card->card_status == CARD_REMOVED){
+		printk("%s:%d,card->card_status: removed\n",__func__,__LINE__);
+		return -ENODEV;
+	}
+	printk("%s:%d,card->card_status:%d\n",__func__,__LINE__,card->card_status);
+	return __card_claim_host(card->host, card);
+}
+static void card_claim_card_put(struct card_host *host)
+{
+	card_release_host(host);
+}
+
+static int emmc_key_kernel_rw(struct memory_card *emmccard,struct emmckey_valid_node_t *emmckey_valid_node,u8 *buf,u32 direct)
+{
+	struct card_blk_data *card_data = card_get_drvdata(emmccard);
+	//SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)emmccard->card_info;
+	struct card_blk_request *brq;
+	//struct card_blk_request *brq2;
+	struct card_queue *cq;
+	struct request_queue *q ;
+	struct request *req;
+	u32 blk_shift,blk_cnt,blk_count;
+	u64 pos;
+	int ret;
+	//cq = memory_card_to_card_queue(emmccard);
+	cq = &card_data->queue;
+	q = cq->queue;
+	if(cq){
+		//printk("%s:%d,cq exist cq:0x%x,cq->bounce_buf:0x%x\n",__func__,__LINE__,(unsigned int)cq,cq->bounce_buf);
+		//printk("%s:%d,cq->req:0x%x,cq->queue:0x%x,cq->sg:0x%x,cq->bounce_sg:0x%x,cq->bounce_sg_len:0x%x\n",
+		//__func__,__LINE__,cq->req,cq->queue,cq->sg,cq->bounce_sg,cq->bounce_sg_len);
+	}
+	
+	brq = kzalloc(sizeof(*brq), GFP_KERNEL);
+	brq->crq.buf = cq->bounce_buf;
+	//printk("%s:%d sd_mmc_phy_buf:0x%x, sd_mmc_buf:0x%x\n",__func__,__LINE__,(unsigned int)sd_mmc_info->sd_mmc_phy_buf,(unsigned int)sd_mmc_info->sd_mmc_buf);
+	
+	//emmccard->card_io_init(emmccard);
+	//emmccard->card_detector(emmccard);
+	//emmccard->card_insert_process(emmccard);
+	//printk("%s:%d,sd_mmc_info->blk_len:%d\n",__func__,__LINE__,1 << card_data->block_bits);
+
+	brq->card_data.sg = cq->sg;
+	brq->card_data.sg_len = 1;//card_queue_map_sg(cq);
+	//printk("%s:%d,cq->sg:0x%x \n",__func__,__LINE__,(unsigned int)cq->sg);
+
+	ret = card_claim_card_get(emmccard);
+	if(ret){
+		printk("%s:%d,card_claim_card_get fail,err:%d\n",__func__,__LINE__,ret);
+	}
+	
+	//printk("%s:%d,host->max_blk_size:%d,host->max_blk_count:%d,\n",
+	//	__func__,__LINE__,emmccard->host->max_blk_size,emmccard->host->max_blk_count);
+	/*note: emmccard->host->max_blk_size is equal (1 << card_data->block_bits)*/
+	brq->card_data.blk_size = 1 << card_data->block_bits;
+	blk_shift = card_data->block_bits;
+	blk_count = emmckey_valid_node->phy_size>>blk_shift;
+	pos = 0;
+	blk_cnt = 0;
+	emmccard->key_protect = 0;
+	while(blk_count){
+		if(blk_count > emmccard->host->max_blk_count){
+			brq->card_data.blk_nums = emmccard->host->max_blk_count;
+		}
+		else{
+			brq->card_data.blk_nums = blk_count;
+		}
+
+		brq->card_data.lba = (emmckey_valid_node->phy_addr>>blk_shift) + blk_cnt;
+		if(direct){
+			brq->crq.cmd = WRITE;
+			memcpy(brq->crq.buf,&buf[pos],brq->card_data.blk_size * brq->card_data.blk_nums);
+		}
+		else{
+			brq->crq.cmd = READ;
+		}
+
+		emmccard->host->card_type = emmccard->card_type;
+		card_wait_for_req(emmccard->host, brq);
+		if(brq->card_data.error != 0){
+			card_claim_card_put(emmccard->host);
+			printk("%s:%d save key data to emmc fail,error:%d\n",__func__,__LINE__,brq->card_data.error);
+			goto error;
+		}
+		if(!direct){//read
+			memcpy(&buf[pos],brq->crq.buf,brq->card_data.blk_size * brq->card_data.blk_nums);
+		}
+		pos += (brq->card_data.blk_size * brq->card_data.blk_nums);
+		blk_cnt += brq->card_data.blk_nums ;
+		blk_count -= brq->card_data.blk_nums;
+	}
+	card_claim_card_put(emmccard->host);
+error:
+	if(brq){
+		kfree(brq);
+	}
+	emmccard->key_protect = 1;
+	return brq->card_data.error;
+}
+#endif
+
+#if defined(EMMC_KEY_UBOOT)
+
+static int emmc_key_uboot_rw(struct mmc *emmccard,struct emmckey_valid_node_t *emmckey_valid_node,u8 *buf,u32 direct)
+{
+	u64 blk,cnt,n;
+	int dev;
+	
+	blk = emmckey_valid_node->phy_addr;
+	cnt = emmckey_valid_node->phy_size;
+	dev = emmccard->block_dev.dev;
+	mmc_init(emmccard);
+	emmccard->key_protect = 0;
+	if(direct){
+		blk >>= uint_to_shift(emmccard->write_bl_len);
+		cnt >>= uint_to_shift(emmccard->write_bl_len);
+		n = emmccard->block_dev.block_write(dev, blk, cnt, buf);
+	}
+	else{
+		blk >>= uint_to_shift(emmccard->read_bl_len);
+		cnt >>= uint_to_shift(emmccard->read_bl_len);
+		n = emmccard->block_dev.block_read(dev, blk, cnt, buf);
+	}
+	emmccard->key_protect = 1;
+	return 0;
+}
+#endif
+
+static int emmc_key_rw(aml_keybox_provider_t *provider,struct emmckey_valid_node_t *emmckey_valid_node,u8 *buf,u32 direct)
+{
+#if defined(EMMC_KEY_KERNEL)
+	struct memory_card *emmccard = (struct memory_card *)provider->priv;
+#elif defined(EMMC_KEY_UBOOT)
+	struct mmc *emmccard = (struct mmc*)provider->priv;
+#endif
+#if defined(EMMC_KEY_KERNEL)
+	return emmc_key_kernel_rw(emmccard,emmckey_valid_node, buf,direct);
+#elif defined(EMMC_KEY_UBOOT)
+	return emmc_key_uboot_rw(emmccard,emmckey_valid_node,buf,direct);
+#endif
+}
+
+static int aml_emmc_key_check(aml_keybox_provider_t *provider)
+{
+	u8 keypart_cnt;
+	u64 part_size;
+	u32 checksum;
+#if defined(EMMC_KEY_KERNEL)
+	struct memory_card *emmccard = (struct memory_card *)provider->priv;
+#elif defined(EMMC_KEY_UBOOT)
+	struct mmc *emmccard = (struct mmc*)provider->priv;
+#endif
+	struct aml_emmckey_info_t *emmckey_info = emmccard->aml_emmckey_info;
+	struct emmckey_valid_node_t *emmckey_valid_node,*temp_valid_node;
+	struct emmckey_data_t *emmckey_data;
+	emmckey_info->key_part_count = emmckey_info->keyarea_phy_size / EMMC_KEYAREA_SIZE;
+	if(emmckey_info->key_part_count > EMMC_KEYAREA_COUNT){
+		emmckey_info->key_part_count = EMMC_KEYAREA_COUNT;
+	}
+	keypart_cnt = 0;
+	part_size = EMMC_KEYAREA_SIZE;
+	do{
+		emmckey_valid_node = kzalloc(sizeof(*emmckey_valid_node), GFP_KERNEL);
+		if(emmckey_valid_node == NULL){
+			printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+			return -ENOMEM;
+		}
+		emmckey_valid_node->phy_addr = emmckey_info->keyarea_phy_addr + part_size * keypart_cnt;
+		emmckey_valid_node->phy_size = EMMC_KEYAREA_SIZE;
+		emmckey_info->key_valid = 0;
+		if(emmckey_info->key_valid_node == NULL){
+			emmckey_info->key_valid_node = emmckey_valid_node;
+		}
+		else{
+			temp_valid_node = emmckey_info->key_valid_node;
+			while(temp_valid_node->next != NULL){
+				temp_valid_node = temp_valid_node->next;
+			}
+			temp_valid_node->next = emmckey_valid_node;
+		}
+	}while(++keypart_cnt < emmckey_info->key_part_count);
+	
+#if 0
+	/*read key data from emmc key area*/
+	temp_valid_node = emmckey_info->key_valid_node;
+	if(temp_valid_node == NULL){
+		printk("%s:%d,don't find emmc key valid node\n",__func__,__LINE__);
+		return -1;
+	}
+	emmckey_data = kzalloc(sizeof(*emmckey_data), GFP_KERNEL);
+	if(emmckey_data == NULL){
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	/*read key data */
+	memset(emmckey_data,0,sizeof(*emmckey_data));
+	emmc_key_rw(provider,temp_valid_node,(u8*)emmckey_data,0);
+	if (!memcmp(emmckey_data->keyarea_mark, EMMC_KEY_AREA_SIGNAL, 8)) {
+		checksum = emmckey_calculate_checksum(emmckey_data->data,EMMCKEY_DATA_VALID_LEN);
+		if(checksum == emmckey_data->checksum){
+			emmckey_info->key_valid = 1;
+		}
+	}
+	/*write key data to emmc key area*/
+	if(emmckey_info->key_valid == 0){
+		temp_valid_node = emmckey_info->key_valid_node;
+		while(temp_valid_node){
+			memset(emmckey_data,0,sizeof(*emmckey_data));
+			memcpy(emmckey_data->keyarea_mark, EMMC_KEY_AREA_SIGNAL, 8);
+			emmckey_data->checksum = emmckey_calculate_checksum(emmckey_data->data,EMMCKEY_DATA_VALID_LEN);
+			emmc_key_rw(provider,temp_valid_node,(u8*)emmckey_data,1);
+			temp_valid_node = temp_valid_node->next;
+		}
+		emmckey_info->key_valid = 1;
+	}
+	kfree(emmckey_data);
+#else
+	emmckey_info->key_valid = 1;
+#endif
+	return 0;
+}
+
+static int32_t emmc_keybox_read(aml_keybox_provider_t * provider, uint8_t *buf,int32_t size,int flags)
+{
+	int err = -1;
+	u32 checksum;
+#if defined(EMMC_KEY_KERNEL)
+	struct memory_card *emmccard = (struct memory_card *)provider->priv;
+#elif defined(EMMC_KEY_UBOOT)
+	struct mmc *emmccard = (struct mmc*)provider->priv;
+#endif
+	struct aml_emmckey_info_t *emmckey_info = emmccard->aml_emmckey_info;
+	struct emmckey_valid_node_t *emmckey_valid_node;
+	struct emmckey_data_t *emmckey_data;
+
+	if(!emmckey_info->key_valid){
+		printk("%s:%d,can't read emmc key\n",__func__,__LINE__);
+		return -1;
+	}
+	if(size > EMMCKEY_DATA_VALID_LEN){
+		printk("%s:%d,size is too big,fact:0x%x,need:0x%x\n",__func__,__LINE__,size,EMMCKEY_DATA_VALID_LEN);
+		return -1;
+	}
+	emmckey_data = kzalloc(sizeof(*emmckey_data), GFP_KERNEL);
+	if(emmckey_data == NULL){
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+
+	emmckey_valid_node = emmckey_info->key_valid_node;
+	while(emmckey_valid_node){
+		memset(emmckey_data,0,sizeof(*emmckey_data));
+		err = emmc_key_rw(provider,emmckey_valid_node,(u8*)emmckey_data,0);
+		if(err == 0){
+			emmc_key_transfer(emmckey_data->keyarea_mark,&emmckey_data->keyarea_mark_checksum,8,0);
+			if (!memcmp(emmckey_data->keyarea_mark, EMMC_KEY_AREA_SIGNAL, 8)){
+				checksum = emmckey_calculate_checksum(emmckey_data->data,EMMCKEY_DATA_VALID_LEN);
+				if(checksum == emmckey_data->checksum){
+					memcpy(buf,emmckey_data->data,size);
+					err = 0;
+					break;
+				}
+			}
+		}
+		emmckey_valid_node = emmckey_valid_node->next;
+	}
+	if(emmckey_data){
+		kfree(emmckey_data);
+	}
+	return err;
+}
+
+
+static int32_t emmc_keybox_write(aml_keybox_provider_t * provider, uint8_t *buf,int32_t size)
+{
+	int err = 0;
+#if defined(EMMC_KEY_KERNEL)
+	struct memory_card *emmccard = (struct memory_card *)provider->priv;
+#elif defined(EMMC_KEY_UBOOT)
+	struct mmc *emmccard = (struct mmc*)provider->priv;
+#endif
+	struct aml_emmckey_info_t *emmckey_info = emmccard->aml_emmckey_info;
+	struct emmckey_valid_node_t *emmckey_valid_node;
+	struct emmckey_data_t *emmckey_data;
+
+	if(!emmckey_info->key_valid){
+		printk("%s:%d,can't write emmc key\n",__func__,__LINE__);
+		return -1;
+	}
+	if(size > EMMCKEY_DATA_VALID_LEN){
+		printk("%s:%d,size is too big,fact:0x%x,need:0x%x\n",__func__,__LINE__,size,EMMCKEY_DATA_VALID_LEN);
+		return -1;
+	}
+	emmckey_data = kzalloc(sizeof(*emmckey_data), GFP_KERNEL);
+	if(emmckey_data == NULL){
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	
+	memset(emmckey_data,0,sizeof(*emmckey_data));
+	memcpy(emmckey_data->keyarea_mark, EMMC_KEY_AREA_SIGNAL, 8);
+	emmc_key_transfer(emmckey_data->keyarea_mark,&emmckey_data->keyarea_mark_checksum,8,1);
+	memcpy(emmckey_data->data,buf,size);
+	emmckey_data->checksum = emmckey_calculate_checksum(emmckey_data->data,EMMCKEY_DATA_VALID_LEN);
+	emmckey_valid_node = emmckey_info->key_valid_node;
+	while(emmckey_valid_node){
+		err = emmc_key_rw(provider,emmckey_valid_node,(u8*)emmckey_data,1);
+		if(err != 0){
+			printk("%s:%d,write key data fail,err:%d\n",__func__,__LINE__,err);
+		}
+		emmckey_valid_node = emmckey_valid_node->next;
+	}
+	if(emmckey_data){
+		kfree(emmckey_data);
+	}
+	return err;
+}
+
+
+/*
+ * 1  when key data is wrote to emmc, add checksum to verify if the data is correct;
+ *    when key data is read from emmc, use checksum to verify if the data is correct.
+ * 2  read/write size is constant 
+ * 3  setup link table to link different area same as nand.
+ * 4  key area is split 2 or more area to save key data
+ * */
+
+#if 0
+//static char write_buf[2][50]={"write 2 : 22222222222","write 3 : 33333333333333"};
+static char write_buf[50]={"write 2 : 22222222222"};
+
+static char read_buf[100]={0};
+
+#include <asm-generic/uaccess.h>
+static int32_t emmc_keybox_read_file(aml_keybox_provider_t * provider, uint8_t *buf,int32_t size,int flags)
+{
+	char filename[3][30]={"/dev/cardblkinand2","/dev/cardblkinand3","/dev/cardblkinand4"};
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos;
+	int i;
+	//char *file = provider->priv;
+	char *file;
+	memset(read_buf,0,sizeof(read_buf));
+	for(i=0;i<3;i++){
+		file = &filename[i][0];
+		fp = filp_open(file, O_RDWR, 0644); 
+		if (IS_ERR(fp)) { 
+			printk("open file error:%s \n",file); 
+			return -1; 
+		}
+		printk("open file ok:%s \n",file); 
+		fs = get_fs(); 
+		set_fs(KERNEL_DS); 
+		pos = 0; 
+		//buf = &read_buf[i][0];
+		//size = 55;
+		vfs_read(fp, buf, size, &pos); 
+		filp_close(fp, NULL); 
+		set_fs(fs); 
+		memcpy(&read_buf[0],buf,55);
+		printk("%s:%d,read data:%s \n",__func__,__LINE__,&read_buf[0]); 
+	}
+	return 0;
+}
+static int32_t emmc_keybox_write_file(aml_keybox_provider_t * provider, uint8_t *buf,int32_t size)
+{
+	char filename[2][30]={"/dev/cardblkinand2","/dev/cardblkinand3"};
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos;
+	int i;
+	char *file;// = provider->priv;
+	for(i=0;i<2;i++){
+		file = &filename[i][0];
+		fp = filp_open(file, O_RDWR, 0644); 
+		if (IS_ERR(fp)) { 
+			printk("open file error\n"); 
+			return -1; 
+		} 
+		printk("%s:%d,open file ok:%s \n",__func__,__LINE__,file); 
+		fs = get_fs(); 
+		set_fs(KERNEL_DS); 
+		pos = 0; 
+		memcpy(buf,&write_buf[0],55);
+		//size = 55;
+		vfs_write(fp, buf, size, &pos); 
+		filp_close(fp, NULL); 
+		set_fs(fs); 
+	}
+	return 0;
+}
+#endif
+
+static aml_keybox_provider_t emmc_provider={
+		.name="emmc_key",
+		.read=emmc_keybox_read,
+		.write=emmc_keybox_write,
+	//	.read=emmc_keybox_read_file,
+	//	.write=emmc_keybox_write_file,
+
+};
+
+
+int emmc_key_init( void *keypara)
+{
+	int i;
+	u64  addr=0;
+	u32  size=0;
+	u32  lba_start=0,lba_end=0,blk_len=0;
+	int err = 0;
+#if defined(EMMC_KEY_KERNEL) //kernel
+	struct memory_card *card = (struct memory_card*)keypara;
+	struct card_blk_data *card_data = card_get_drvdata(card);
+#elif defined(EMMC_KEY_UBOOT) //uboot
+	struct mmc *card = (struct mmc*)keypara;
+#endif
+	struct aml_emmckey_info_t *emmckey_info;
+	//printk("card key: card_blk_probe. \n");
+	emmckey_info = kzalloc(sizeof(*emmckey_info), GFP_KERNEL);
+	if(emmckey_info == NULL){
+		printk("%s:%d,kzalloc memory fail\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	emmckey_info->key_init = 0;
+	card->aml_emmckey_info = emmckey_info;
+
+#if defined(EMMC_KEY_KERNEL) 
+		if(card->card_plat_info->nr_partitions>0)
+		{
+			struct mtd_partition    *partitions_start=NULL,*partitions_end=NULL;
+			int part_start=-1,part_end=-1;
+			
+			for(i=0;i<card->card_plat_info->nr_partitions;i++){
+				if(strcmp(card->card_plat_info->partitions[i].name,KEY_PREVIOUS_PARTITION)==0){
+					partitions_start = &card->card_plat_info->partitions[i];
+					part_start = i;
+				}
+				if(strcmp(card->card_plat_info->partitions[i].name,KEY_LATER_PARTITION)==0){
+					partitions_end = &card->card_plat_info->partitions[i];
+					part_end = i;
+					break;
+				}
+			}
+			if(i>=card->card_plat_info->nr_partitions){
+				printk("don't find correct partition name\n");
+				return -1;
+			}
+			if((part_end == -1) || (part_start == -1) ){
+				printk("don't find part:%s or part:%s\n",KEY_PREVIOUS_PARTITION,KEY_LATER_PARTITION);
+				return -1;
+			}
+			if(((part_end-part_start) > 1) || ((part_end-part_start) < 0)){
+				printk("between %s and %s,interval parts is %d more than 1,or order error\n",KEY_PREVIOUS_PARTITION,KEY_LATER_PARTITION,part_end-part_start);
+				return -1;
+			}
+			addr = partitions_start->offset + partitions_start->size;
+			size = partitions_end->offset - addr;
+			if(size < EMMC_KEYAREA_SIZE){
+				printk("emmc save key area is too smaller,fact size:0x%x,need size:0x%xn\n",size,EMMC_KEYAREA_SIZE);
+				return -1;
+			}
+			if(size > (EMMC_KEYAREA_SIZE * EMMC_KEYAREA_COUNT)){
+				size = EMMC_KEYAREA_SIZE * EMMC_KEYAREA_COUNT;
+			}
+			lba_start = addr >> card_data->block_bits;
+			lba_end = lba_start + (size >> card_data->block_bits) + 1;
+			emmckey_info->key_init = 1;
+			card->key_protect = 1;
+			printk("%s:%d emmc key lba_start:0x%x,lba_end:0x%x \n",__func__,__LINE__,lba_start,lba_end);
+			//printk("%s:%d,host->max_blk_size:%d,host->max_blk_count:%d,block_bits:%d\n",
+			//	__func__,__LINE__,card->host->max_blk_size,card->host->max_blk_count,card_data->block_bits);
+
+		}
+#elif defined(EMMC_KEY_UBOOT)
+	addr = EMMCKEY_AREA_PHY_START_ADDR;
+	size = EMMCKEY_AREA_PHY_SIZE;
+	blk_len = card->write_bl_len;
+	lba_start = addr >> uint_to_shift(card->write_bl_len);
+	lba_end = lba_start + (size >> uint_to_shift(card->write_bl_len)) + 1;
+	emmckey_info->key_init = 1;
+	card->key_protect = 1;
+	printk("%s:%d emmc key lba_start:0x%x,lba_end:0x%x \n",__func__,__LINE__,lba_start,lba_end);
+#endif
+	if(!emmckey_info->key_init){
+		printk("%s:%d,emmc key init fail\n",__func__,__LINE__);
+		kfree(emmckey_info);
+		card->aml_emmckey_info = NULL;
+		return -1;
+	}
+	emmckey_info->keyarea_phy_addr = addr;
+	emmckey_info->keyarea_phy_size = size;
+	emmckey_info->lba_start = lba_start;
+	emmckey_info->lba_end   = lba_end;
+	emmckey_info->blk_size = blk_len;
+	emmckey_info->blk_shift = uint_to_shift(blk_len);
+	emmc_provider.priv=card;
+	err = aml_emmc_key_check(&emmc_provider);
+	if(err){
+		printk("%s:%d,emmc key check fail\n",__func__,__LINE__);
+		kfree(emmckey_info);
+		card->aml_emmckey_info = NULL;
+		return err;
+	}
+	err = aml_keybox_provider_register(&emmc_provider);
+	if(err){
+		BUG();
+	}
+	printk("emmc key: %s:%d ok. \n",__func__,__LINE__);
+
+	return err;
+}
+
diff --git a/drivers/amlogic/cardreader/emmc_key.h b/drivers/amlogic/cardreader/emmc_key.h
new file mode 100644
index 0000000..e2a89dc
--- /dev/null
+++ b/drivers/amlogic/cardreader/emmc_key.h
@@ -0,0 +1,61 @@
+#ifndef __EMMC_KEY_H__
+#define __EMMC_KEY_H__
+
+
+#define EMMC_KEY_KERNEL
+//#define EMMC_KEY_UBOOT
+
+#ifdef EMMC_KEY_UBOOT
+#include <config.h>
+#endif
+
+#define EMMC_KEY_AREA_SIGNAL		"emmckeys"
+#define EMMC_KEY_AREA_SIGNAL_LEN	16
+
+#define EMMC_KEYAREA_SIZE		(64*1024)
+#define EMMC_KEYAREA_COUNT		2
+
+#if defined(EMMC_KEY_KERNEL)
+#define KEY_PREVIOUS_PARTITION 	"boot_env"
+#define KEY_LATER_PARTITION		"logo"
+#endif
+#ifdef EMMC_KEY_UBOOT
+//#define EMMCKEY_AREA_PHY_START_ADDR    (0x60000+0x2000)
+//#define EMMCKEY_AREA_PHY_SIZE          (128*1024)
+#define EMMCKEY_AREA_PHY_START_ADDR    (CONFIG_ENV_OFFSET+CONFIG_ENV_SIZE)
+#define EMMCKEY_AREA_PHY_SIZE          (128*1024)
+#endif
+
+struct emmckey_valid_node_t {
+	u64 phy_addr;
+	u32 phy_size;
+	struct emmckey_valid_node_t *next;
+};
+
+struct aml_emmckey_info_t {
+	//struct memory_card *card;
+	struct emmckey_valid_node_t *key_valid_node;
+	u64    keyarea_phy_addr;
+	u32    keyarea_phy_size;
+	u32    lba_start;
+	u32    lba_end;
+	u32    blk_size;
+	u32    blk_shift;
+	u8     key_init;
+	u8     key_valid;
+	u8     key_part_count;
+};
+
+#define EMMCKEY_DATA_VALID_LEN		(EMMC_KEYAREA_SIZE - EMMC_KEY_AREA_SIGNAL_LEN - 4 - 4 -4)
+struct emmckey_data_t {
+	u8     keyarea_mark[EMMC_KEY_AREA_SIGNAL_LEN];
+	u32	   keyarea_mark_checksum;
+	u32    checksum;
+	u32    reserve;
+	u8     data[EMMCKEY_DATA_VALID_LEN];
+};
+
+extern int emmc_key_init( void *keypara);
+
+#endif
+
diff --git a/drivers/amlogic/cardreader/sd/sd.c b/drivers/amlogic/cardreader/sd/sd.c
index edd9e02..8dc0eb8a 100755
--- a/drivers/amlogic/cardreader/sd/sd.c
+++ b/drivers/amlogic/cardreader/sd/sd.c
@@ -23,6 +23,11 @@
 #include "sd_misc.h"
 #include "sd_protocol.h"
 
+#ifdef CONFIG_AML_EMMC_KEY
+#include "../emmc_key.h"
+#endif
+
+
 struct memory_card *card_find_card(struct card_host *host, u8 card_type); 
 
 void sd_insert_detector(struct memory_card *card)
@@ -136,8 +141,6 @@ void sd_resume(struct memory_card *card)
 {
 	printk("***Entered %s:%s\n", __FILE__,__func__);
 }
-
-
 static int sd_request(struct memory_card *card, struct card_blk_request *brq)
 {
 	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
@@ -150,6 +153,19 @@ static int sd_request(struct memory_card *card, struct card_blk_request *brq)
 	lba = brq->card_data.lba;
 	byte_cnt = brq->card_data.blk_size * brq->card_data.blk_nums;
 	data_buf = brq->crq.buf;
+	//printk("%s:%d,write:%s   data_buf:0x%x,brq->crq.buf:0x%x\n",__func__,__LINE__,data_buf,(unsigned int)data_buf,(unsigned int)brq->crq.buf);
+
+#ifdef CONFIG_AML_EMMC_KEY
+	if(card->key_protect){
+		if(card->aml_emmckey_info){
+			if((lba > card->aml_emmckey_info->lba_start ) &&( lba < card->aml_emmckey_info->lba_end)){
+				//printk("%s:%d,area read/write protect\n",__func__,__LINE__);
+				return 0;
+			}
+		}
+	}
+#endif
+	//printk("%s:%d,lba:0x%x \n",__func__,__LINE__,lba);
 
 	if(sd_mmc_info == NULL){
 		brq->card_data.error = SD_MMC_ERROR_NO_CARD_INS;
@@ -467,13 +483,6 @@ int inand_probe(struct memory_card *card)
         sdio_info->sd_mmc_power_delay = 0;
 #endif
 
-
-#ifdef CONFIG_AML_CARD_KEY
-	{
-		int card_key_init(struct memory_card *card);
-		card_key_init(card);
-	}
-#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/efuse/keys/core.c b/drivers/amlogic/efuse/keys/core.c
index 0d36a6c..aa40f6f 100755
--- a/drivers/amlogic/efuse/keys/core.c
+++ b/drivers/amlogic/efuse/keys/core.c
@@ -399,7 +399,6 @@ static int aml_key_decrypt(void *dst, size_t *dst_len, const void *src,
  */
 static int debug_mode = 1;//1:debug,0:normal
 static int postpone_write = 0; //1:postpone, 0:normal once write
-static int rewrite_nandkey=1;//1:disable,0:enable
 
 static ssize_t mode_show(struct device *dev, struct device_attribute *attr,
                          char *buf)
@@ -503,9 +502,11 @@ static int aml_key_read_hash(aml_key_t * key, char * hash)
 #else
 static int aml_key_write_hash(aml_key_t * key, char * hash)
 {
+	return 0;
 }
 static int aml_key_read_hash(aml_key_t * key, char * hash)
 {
+	return 0;
 }
 #endif
 
@@ -625,7 +626,9 @@ static ssize_t aml_key_store(aml_key_t * key, const char *buf, size_t count)
     int i, j, err;
     char * data = NULL;
     char * enc_data = NULL;
+#if ENABLE_AML_KEY_DEBUG
     char * temp = NULL;
+#endif
     size_t in_key_len=0;
     uint16_t checksum=0;
     size_t readbuff_validlen;
@@ -825,8 +828,8 @@ int32_t aml_keys_set_version(struct device *dev, uint8_t version, int storer)
     char **keyfile = (char**) dev->platform_data;
     int i, ret;
     int keyfile_index;
-    if (keys_version > 0 && keys_version < 256) ///has been initial
-        return -1;
+    //if (keys_version > 0 && keys_version < 256) ///has been initial
+    //    return -1;
 
 #ifdef TEST_NAND_KEY_WR
 	printk("version:%d,%s\n",version,__func__);
@@ -845,7 +848,7 @@ int32_t aml_keys_set_version(struct device *dev, uint8_t version, int storer)
 //    printk("keyfile:%s\n",keyfile[0]);
 //    printk("keyfile:%s\n",keyfile[1]);
     if (key_schematic[version] == NULL
-            || key_schematic[version]->init(key_schematic[version], keyfile[0])
+            || key_schematic[version]->init(key_schematic[version], keyfile[keyfile_index])
                     < 0) ///@todo Platform Data
     {
         printk(KERN_ERR KEYS_DEVICE_NAME ": version %d can not be init %p\n",
@@ -979,8 +982,8 @@ static ssize_t version_store(struct device *dev, struct device_attribute *attr,
 
     if (new < 1 || new > 255)
         return ret;
-    if (keys_version > 0 && keys_version < 256)
-        return ret;
+    //if (keys_version > 0 && keys_version < 256)
+    //    return ret;
 
     if (aml_keys_set_version(dev, new,storer) < 0)
     {
@@ -1061,6 +1064,7 @@ static ssize_t key_list_show(struct device *dev, struct device_attribute *attr,
 static ssize_t key_list_store(struct device *dev, struct device_attribute *attr,
                              const char *buf, size_t count)
 {
+	return -EINVAL;
 }
 //DEVICE_ATTR(key_list, 0660, key_list_show, key_list_store);
 
@@ -1086,7 +1090,7 @@ static ssize_t key_name_store(struct device *dev, struct device_attribute *attr,
 	keys = key_schematic[keys_version]->keys;
 	if (strncmp(buf, "rename", 6) == 0)
 	{
-		cmd = &buf[6];
+		cmd = (char*)&buf[6];
 		for(i=0;i<key_schematic[keys_version]->count;i++)
 		{
 			oldname = strstr(cmd,keys[i].name);
@@ -1133,7 +1137,7 @@ static ssize_t key_name_store(struct device *dev, struct device_attribute *attr,
 	}
 	else if(strncmp(buf, "set", 3) == 0)
 	{
-		cmd = &buf[3];
+		cmd = (char*)&buf[3];
 		for(i=0;i<key_schematic[keys_version]->count;i++)
 		{
 			oldname = strstr(cmd,keys[i].name);
@@ -1149,7 +1153,7 @@ static ssize_t key_name_store(struct device *dev, struct device_attribute *attr,
 		return count;
 	}
 	
-	cmd = &buf[0];
+	cmd = (char*)&buf[0];
 	newname = cmd;
 	oldname = cmd;
 	cnt=0;
@@ -1193,6 +1197,7 @@ static ssize_t key_name_store(struct device *dev, struct device_attribute *attr,
 static ssize_t key_write_show(struct device *dev, struct device_attribute *attr,
                             char *buf)
 {
+	return -EINVAL;
 }
 static ssize_t key_write_store(struct device *dev, struct device_attribute *attr,
                              const char *buf, size_t count)
@@ -1222,6 +1227,8 @@ static ssize_t key_read_show(struct device *dev, struct device_attribute *attr,
 static ssize_t key_read_store(struct device *dev, struct device_attribute *attr,
                              const char *buf, size_t count)
 {
+	int err = -EINVAL;
+	return err;
 }
 //DEVICE_ATTR(key_read, 0660, key_read_show, key_read_store);
 
@@ -1558,15 +1565,15 @@ int get_aml_key_kernel(const char* key_name, unsigned char* data, int ascii_flag
 		if (ascii_flag == 0) {
 			for (i=0, j=0; (i < MAX_BUF_LEN) && (buf[i]!=0); i++, j++){
 				data[j]= (((asc_to_i(buf[i]))<<4) | (asc_to_i(buf[++i])));
-                        }
-                        ret = ret >> 1;
-                } else {
-                	strncpy(data, buf, MAX_BUF_LEN);
-                }
-        }
-        kfree(buf);
-        buf = NULL;
-        return ret;
+			}
+			ret = ret >> 1;
+		} else {
+			strncpy(data, buf, MAX_BUF_LEN);
+		}
+	}
+	kfree(buf);
+	buf = NULL;
+	return ret;
 }
 #endif
 EXPORT_SYMBOL(get_aml_key_kernel);
@@ -1719,6 +1726,7 @@ static int aml_keys_probe(struct platform_device *pdev)
         goto error4;
     }
     trigger_key_init();
+    keys_version = 0;
     return 0;
 
     error4: cdev_del(&keys_devp->cdev);
@@ -1753,15 +1761,18 @@ static struct platform_driver aml_keys_driver =
 
 struct device_type_s{
 	char devname[16];
-	char platname[16];
+	char storername[16];
+	int  storer_index;
 };
 #define DEVICE_TYPE_MAP_COUNT	2
 static struct device_type_s device_type_map[DEVICE_TYPE_MAP_COUNT]={
 	[0]={
 		.devname="nand3",
+		.storer_index = NAND_STORE_KEY_INDEX,
 	},
 	[1]={
 		.devname="emmc3",
+		.storer_index = EMMC_STORE_KEY_INDEX,
 	},
 };
 
@@ -1771,7 +1782,7 @@ int extenal_api_key_set_version(char *devvesion)
 	int flag;
 	struct device_type_s *pdev = &device_type_map[0];
 	flag = 0;
-	for(i=0;i<DEVICE_TYPE_MAP_COUNT;i++){
+	for(i=0;i<DEVICE_TYPE_MAP_COUNT;i++,pdev++){
 		if(strcmp(devvesion,pdev->devname) == 0){
 			flag = 1;
 			break;
@@ -1786,7 +1797,7 @@ int extenal_api_key_set_version(char *devvesion)
 		return -EINVAL;
 	}
 
-	err = aml_keys_set_version(key_device, version_check(), 0);
+	err = aml_keys_set_version(key_device, version_check(), pdev->storer_index);
 	if(err < 0){
 		printk("uboot key init fail,%s:%d\n",__func__,__LINE__);
 	}
diff --git a/include/linux/cardreader/amlkey.h b/include/linux/cardreader/amlkey.h
deleted file mode 100755
index 722a588..0000000
--- a/include/linux/cardreader/amlkey.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef AMLKEY_H
-#define AMLKEY_H
-
-#define MINIKEY_PART_SIZE				0x800000
-#define CONFIG_KEYSIZE         		0x2000
-#define ENV_KEY_MAGIC					"keyx"
-#define AML_KEY_DEVICE_NAME	"nand_key"
-
-
-struct key_oobinfo_t {
-	char name[4];
-    int16_t  ec;
-    unsigned        timestamp: 15;
-    unsigned       status_page: 1;
-};
-
-struct key_valid_node_t {
-	int16_t  ec;
-	int16_t	phy_blk_addr;
-	int16_t	phy_page_addr;
-	int timestamp;
-};
-
-struct key_free_node_t {
-	int16_t  ec;
-	int16_t	phy_blk_addr;
-	int dirty_flag;
-	struct key_free_node_t *next;
-};
-
-struct aml_key_info_t {
-	void   *owner;
-	struct key_valid_node_t *env_valid_node;
-	struct key_free_node_t *env_free_node;
-	u_char key_valid;
-	u_char key_init;
-//	int key_phy_addr;
-//	int key_phy_size;
-};
-
-
-#define KEYSIZE (CONFIG_KEYSIZE - (sizeof(uint32_t)))
-typedef	struct  {
-	uint32_t	crc;		/* CRC32 over data bytes	*/
-	unsigned char	data[KEYSIZE]; /* Environment data		*/
-} mesonkey_t;
-
-
-
-#endif
\ No newline at end of file
diff --git a/include/linux/cardreader/card_block.h b/include/linux/cardreader/card_block.h
index da97d63..a40b6f6 100755
--- a/include/linux/cardreader/card_block.h
+++ b/include/linux/cardreader/card_block.h
@@ -40,14 +40,6 @@ struct sdio_cis {
 	unsigned short		blksize;
 	unsigned int		max_dtr;
 };
-#ifdef CONFIG_AML_CARD_KEY
-struct card_key_info{
-	unsigned short  key_init;
-	unsigned short  key_valid;
-	unsigned int    key_phy_addr;
-	unsigned int    key_phy_size;
-};
-#endif
 struct card_driver {
 	struct device_driver drv;
 	int (*probe)(struct memory_card *);
@@ -80,8 +72,9 @@ struct memory_card {
 
 	struct aml_card_info *card_plat_info;
 	void				 *card_info;
-#ifdef CONFIG_AML_CARD_KEY
-	struct card_key_info    *key_info;
+#ifdef CONFIG_AML_EMMC_KEY
+	u32 key_protect;
+	struct aml_emmckey_info_t *aml_emmckey_info;
 #endif
 
 	u8					card_status;
@@ -270,9 +263,6 @@ extern int card_schedule_work(struct work_struct *work);
 extern int card_schedule_delayed_work(struct delayed_work *work, unsigned long delay);
 extern void card_release_host(struct card_host *host);
 
-#ifdef CONFIG_AML_CARD_KEY
-extern int card_key_init(struct memory_card *card);
-#endif
 
 extern void sd_io_init(struct memory_card *card);
 #endif
